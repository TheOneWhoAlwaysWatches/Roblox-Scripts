-- ⚡ No Cooldown V14 - Respawn-Proof (Global Manager version) ⚡
-- Keeps your original behavior but will NOT break on respawn

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- === CONFIG (same idea as before) ===
local maxPerSecondPerTool = 45      -- cap per tool (you had 45)
local interval = 1 / maxPerSecondPerTool

-- === Cooldown Nuker ===
local function nukeCooldowns(obj)
    if not obj or not obj.GetDescendants then return end
    for _, v in ipairs(obj:GetDescendants()) do
        if v:IsA("BoolValue") or v:IsA("NumberValue") then
            local nameLower = tostring(v.Name):lower()
            if nameLower:find("cool") or nameLower:find("cd") or nameLower:find("debounce") or nameLower:find("delay") then
                pcall(function()
                    if v:IsA("BoolValue") then
                        v.Value = false
                    else
                        v.Value = 0
                    end
                end)
                -- keep nuked if something tries to change it
                v.Changed:Connect(function()
                    pcall(function()
                        if v:IsA("BoolValue") then
                            v.Value = false
                        else
                            v.Value = 0
                        end
                    end)
                end)
            end
        end
    end
end

-- initial nuke on player and watch future descendants
pcall(function() nukeCooldowns(LocalPlayer) end)
LocalPlayer.DescendantAdded:Connect(function(desc)
    pcall(function() nukeCooldowns(desc) end)
end)

-- === Manager state ===
local patchedTools = setmetatable({}, { __mode = "k" })     -- weak-key set of patched tool => true
local activeTools = setmetatable({}, { __mode = "k" })      -- weak-key set of tools currently "Activated" by player clicks
local toolConns = setmetatable({}, { __mode = "k" })        -- tool -> table of connections for cleanup

-- Helper: safe find remote under tool (like before)
local function findToolRemote(tool)
    if not tool or not tool.GetDescendants then return nil end
    for _, d in ipairs(tool:GetDescendants()) do
        if d:IsA("RemoteEvent") or d:IsA("RemoteFunction") then
            return d
        end
    end
    -- fallback: name "FightEvent" deep search
    local fe = tool:FindFirstChild("FightEvent", true)
    if fe and (fe:IsA("RemoteEvent") or fe:IsA("RemoteFunction")) then return fe end
    return nil
end

-- Stop tracking tool (clean loops)
local function unpatchTool(tool)
    if not tool then return end
    local conns = toolConns[tool]
    if conns then
        for _, c in ipairs(conns) do
            if c and c.Connected then
                pcall(function() c:Disconnect() end)
            end
        end
    end
    toolConns[tool] = nil
    patchedTools[tool] = nil
    activeTools[tool] = nil
end

-- Patch a tool (idempotent)
local function patchTool(tool)
    if not tool or not tool:IsA("Tool") then return end
    if patchedTools[tool] then return end
    patchedTools[tool] = true

    -- try to clear cooldown-like values inside tool
    pcall(function() nukeCooldowns(tool) end)

    -- keep track of connections for cleanup
    local conns = {}
    toolConns[tool] = conns

    -- When player activates the tool (mouse click / button), mark it active
    local ok, activatedConn = pcall(function()
        return tool.Activated:Connect(function()
            -- mark active; global loop will handle firing at capped rate
            activeTools[tool] = true
        end)
    end)
    if ok and activatedConn then table.insert(conns, activatedConn) end

    -- Use Unequipped to stop auto-firing if the tool was unequipped
    local ok2, unequipConn = pcall(function()
        return tool.Unequipped:Connect(function()
            activeTools[tool] = nil
        end)
    end)
    if ok2 and unequipConn then table.insert(conns, unequipConn) end

    -- If tool gets destroyed / removed, cleanup
    local ok3, destroyedConn = pcall(function()
        return tool.Destroying:Connect(function()
            activeTools[tool] = nil
            unpatchTool(tool)
        end)
    end)
    if ok3 and destroyedConn then table.insert(conns, destroyedConn) end

    -- Also monitor ancestry changes - if tool leaves character/backpack we stop it
    local ok4, ancestryConn = pcall(function()
        return tool.AncestryChanged:Connect(function(_, parent)
            if not parent then
                activeTools[tool] = nil
            end
        end)
    end)
    if ok4 and ancestryConn then table.insert(conns, ancestryConn) end
end

-- Patch everything currently in backpack and character (safe)
local function patchAllCurrentTools()
    pcall(function()
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if backpack then
            for _, t in ipairs(backpack:GetChildren()) do
                pcall(patchTool, t)
            end
        end
    end)
    pcall(function()
        local char = LocalPlayer.Character
        if char then
            for _, t in ipairs(char:GetChildren()) do
                pcall(patchTool, t)
            end
        end
    end)
end

-- Watch for tools added to Backpack or Character (respawn & pickups)
LocalPlayer.Backpack.ChildAdded:Connect(function(child)
    task.delay(0.05, function() patchTool(child) end)
end)
LocalPlayer.Backpack.ChildRemoved:Connect(function(child)
    -- if removed (dropped), ensure cleanup
    task.delay(0.05, function() unpatchTool(child) end)
end)

-- CharacterAdded patching (respawn safe)
LocalPlayer.CharacterAdded:Connect(function(char)
    -- wait a touch for objects to initialize
    task.wait(0.05)
    -- nuke cooldowns under new character
    pcall(function() nukeCooldowns(char) end)
    -- patch tools in Backpack and Character after respawn
    patchAllCurrentTools()
    -- when new tools are parented to Character
    char.ChildAdded:Connect(function(child)
        task.delay(0.05, function() patchTool(child) end)
    end)
end)

-- initial patch
patchAllCurrentTools()

-- === Global persistent firing loop ===
-- This loop lives across respawns and services all active tools.
-- It respects the per-tool interval that you wanted (interval variable).
local firing = true
task.spawn(function()
    -- safety: small sleep to allow startup
    task.wait(0.05)
    while firing do
        -- iterate snapshot of active tools (to avoid mutation issues)
        local toolsSnapshot = {}
        for t, _ in pairs(activeTools) do
            if t and t.Parent then
                table.insert(toolsSnapshot, t)
            else
                activeTools[t] = nil
            end
        end

        -- for each tool in snapshot, attempt one capped fire (one token consumed per call)
        for _, tool in ipairs(toolsSnapshot) do
            if tool and tool.Parent and tool:IsA("Tool") then
                -- ensure cooldowns nuked on the tool (defensive)
                pcall(function() nukeCooldowns(tool) end)

                -- find remote (if any) and fire it safely
                local remote = findToolRemote(tool)
                if remote then
                    pcall(function()
                        if remote:IsA("RemoteEvent") then
                            remote:FireServer()
                        else
                            remote:InvokeServer()
                        end
                    end)
                end
                -- small wait between each tool fire to respect per-tool caps
                task.wait(interval)
            end
        end

        -- if we had no active tools this cycle, wait a frame to avoid tight spinning
        if #toolsSnapshot == 0 then
            RunService.Heartbeat:Wait()
        end
    end
end)

-- Safety hook: if player dies we clear active tools (prevents leftover loops)
LocalPlayer.CharacterAdded:Connect(function(char)
    -- when character spawns we clear activeTools briefly (they'll re-add when activated)
    for t, _ in pairs(activeTools) do activeTools[t] = nil end
end)

-- Optional: cleanup function (not necessary but handy)
local function shutdown()
    firing = false
    for t, _ in pairs(activeTools) do activeTools[t] = nil end
    for t, _ in pairs(patchedTools) do unpatchTool(t) end
end

print("⚡ No Cooldown V14 - Respawn-Proof (Global Manager) Loaded - Stable & Fast ⚡")
